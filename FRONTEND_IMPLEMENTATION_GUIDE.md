# üöÄ GUIDE D'IMPL√âMENTATION FRONTEND - SANT√âAFRIK

## üìã Vue d'ensemble

Ce guide d√©taille l'impl√©mentation compl√®te du frontend pour la plateforme Sant√©Afrik, incluant tous les √©crans, flux et int√©grations n√©cessaires.

## üéØ Architecture Frontend Recommand√©e

### Stack Technologique
- **Framework** : React Native (Expo) pour mobile
- **Navigation** : React Navigation v6
- **√âtat** : Redux Toolkit ou Zustand
- **HTTP Client** : Axios
- **Socket** : Socket.IO Client
- **Notifications** : Expo Notifications
- **Upload** : Expo Document Picker + Image Picker

---

## üë§ √âCRANS PATIENT

### 1. üîê Authentification & Inscription

#### √âcran de Connexion
```typescript
// LoginScreen.tsx
const LoginScreen = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleLogin = async () => {
    try {
      const response = await apiService.login({ email, password });
      // Sauvegarder le token
      await AsyncStorage.setItem('token', response.token);
      // Naviguer vers le dashboard
      navigation.navigate('PatientDashboard');
    } catch (error) {
      Alert.alert('Erreur', 'Identifiants incorrects');
    }
  };
};
```

**Endpoints utilis√©s :**
- `POST /api/auth/login`

#### √âcran d'Inscription (OTP)
```typescript
// RegisterScreen.tsx
const RegisterScreen = () => {
  const [email, setEmail] = useState('');
  const [otp, setOtp] = useState('');

  const sendOTP = async () => {
    await apiService.sendOTP({ email: email });
  };

  const verifyOTP = async () => {
    const response = await apiService.verifyOTP({ email: email, code: otp });
    // Cr√©er le compte patient
    await apiService.createPatient(response.token, patientData);
  };
};
```

**Endpoints utilis√©s :**
- `POST /api/auth/send-otp`
- `POST /api/auth/verify-otp`
- `POST /api/patients`

### 2. üè• Recherche de M√©decins

#### √âcran de Recherche Principale
```typescript
// SearchDoctorsScreen.tsx
const SearchDoctorsScreen = () => {
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedSpecialty, setSelectedSpecialty] = useState(null);
  const [doctors, setDoctors] = useState([]);

  const searchDoctors = async () => {
    try {
      const response = await apiService.searchDoctors({
        q: searchQuery,
        specialite_id: selectedSpecialty?.id,
        limit: 20
      });
      setDoctors(response.data);
    } catch (error) {
      console.error('Erreur recherche:', error);
    }
  };

  return (
    <View>
      <SearchBar 
        value={searchQuery}
        onChangeText={setSearchQuery}
        onSearch={searchDoctors}
      />
      <SpecialtyFilter 
        selected={selectedSpecialty}
        onSelect={setSelectedSpecialty}
      />
      <DoctorList doctors={doctors} onSelect={selectDoctor} />
    </View>
  );
};
```

**Endpoints utilis√©s :**
- `GET /api/specialites/medecins/search` (recommand√©)
- `GET /api/specialites/specialites` (pour les filtres)

#### √âcran de D√©tails M√©decin
```typescript
// DoctorDetailsScreen.tsx
const DoctorDetailsScreen = ({ doctor }) => {
  const [availableSlots, setAvailableSlots] = useState([]);

  const loadAvailableSlots = async () => {
    const slots = await apiService.getAvailableSlots(doctor.idmedecin);
    setAvailableSlots(slots);
  };

  return (
    <View>
      <DoctorProfile doctor={doctor} />
      <AvailableSlots 
        slots={availableSlots}
        onSelectSlot={bookAppointment}
      />
    </View>
  );
};
```

**Endpoints utilis√©s :**
- `GET /api/rendezvous/medecin/:medecinId/creneaux-disponibles`

### 3. üìÖ Prise de Rendez-vous

#### √âcran de R√©servation
```typescript
// BookAppointmentScreen.tsx
const BookAppointmentScreen = ({ doctor, selectedSlot }) => {
  const [appointmentType, setAppointmentType] = useState('PRESENTIEL');
  const [motif, setMotif] = useState('');
  const [documents, setDocuments] = useState([]);

  const bookAppointment = async () => {
    try {
      const appointmentData = {
        patient_id: user.idPatient,
        medecin_id: doctor.idmedecin,
        creneau_id: selectedSlot.idcreneau,
        dateheure: selectedSlot.debut,
        duree: selectedSlot.duree,
        motif: motif,
        type_rdv: appointmentType,
        adresse_cabinet: appointmentType === 'PRESENTIEL' ? doctor.cabinet?.adresse : null
      };

      const response = await apiService.createAppointment(appointmentData);
      
      // Upload documents si n√©cessaire
      if (documents.length > 0) {
        await uploadDocuments(response.idrendezvous, documents);
      }

      navigation.navigate('AppointmentConfirmation', { appointment: response });
    } catch (error) {
      Alert.alert('Erreur', 'Impossible de r√©server le rendez-vous');
    }
  };
};
```

**Endpoints utilis√©s :**
- `POST /api/rendezvous`
- `POST /api/dossier-medical/documents` (pour les documents)

### 4. üì± Dashboard Patient

#### √âcran Principal
```typescript
// PatientDashboardScreen.tsx
const PatientDashboardScreen = () => {
  const [upcomingAppointments, setUpcomingAppointments] = useState([]);
  const [recentMessages, setRecentMessages] = useState([]);

  useEffect(() => {
    loadUpcomingAppointments();
    loadRecentMessages();
  }, []);

  const loadUpcomingAppointments = async () => {
    const appointments = await apiService.getPatientAppointments(user.idPatient);
    setUpcomingAppointments(appointments.filter(apt => 
      new Date(apt.dateheure) > new Date() && 
      ['CONFIRME', 'EN_ATTENTE_CONSULTATION', 'EN_COURS'].includes(apt.statut)
    ));
  };

  return (
    <ScrollView>
      <WelcomeSection user={user} />
      <UpcomingAppointments appointments={upcomingAppointments} />
      <QuickActions />
      <RecentMessages messages={recentMessages} />
    </ScrollView>
  );
};
```

**Endpoints utilis√©s :**
- `GET /api/rendezvous/patient/:patientId`

### 5. üí¨ Messagerie Patient

#### √âcran de Conversations
```typescript
// ConversationsScreen.tsx
const ConversationsScreen = () => {
  const [conversations, setConversations] = useState([]);

  const loadConversations = async () => {
    const convs = await apiService.getConversations();
    setConversations(convs);
  };

  const startConversation = async (doctorId) => {
    try {
      const conversation = await apiService.createPrivateConversation(doctorId);
      navigation.navigate('Chat', { conversationId: conversation.idconversation });
    } catch (error) {
      Alert.alert('Erreur', 'Impossible de d√©marrer la conversation');
    }
  };

  return (
    <View>
      <ConversationList 
        conversations={conversations}
        onSelect={navigateToChat}
      />
      <FloatingActionButton onPress={showDoctorList} />
    </View>
  );
};
```

**Endpoints utilis√©s :**
- `GET /api/messagerie/conversations`
- `POST /api/messagerie/conversations/private`

#### √âcran de Chat
```typescript
// ChatScreen.tsx
const ChatScreen = ({ conversationId }) => {
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');

  useEffect(() => {
    // √âcouter les nouveaux messages via Socket.IO
    socket.on('new_message', (message) => {
      if (message.conversation_id === conversationId) {
        setMessages(prev => [...prev, message]);
      }
    });

    loadMessages();
  }, [conversationId]);

  const sendMessage = async () => {
    try {
      await apiService.sendMessage({
        conversationId,
        contenu: newMessage,
        type: 'TEXTE'
      });
      setNewMessage('');
    } catch (error) {
      Alert.alert('Erreur', 'Impossible d\'envoyer le message');
    }
  };

  return (
    <View style={styles.container}>
      <MessageList messages={messages} />
      <MessageInput 
        value={newMessage}
        onChangeText={setNewMessage}
        onSend={sendMessage}
      />
    </View>
  );
};
```

**Endpoints utilis√©s :**
- `GET /api/messagerie/conversations/:id/messages`
- `POST /api/messagerie/messages`

### 6. üìÅ Dossier M√©dical

#### √âcran du Dossier
```typescript
// MedicalRecordScreen.tsx
const MedicalRecordScreen = () => {
  const [medicalRecord, setMedicalRecord] = useState(null);
  const [documents, setDocuments] = useState([]);

  const loadMedicalRecord = async () => {
    const record = await apiService.getMedicalRecord();
    setMedicalRecord(record);
  };

  const loadDocuments = async () => {
    const docs = await apiService.getMedicalDocuments(medicalRecord.iddossier);
    setDocuments(docs);
  };

  const uploadDocument = async () => {
    const result = await DocumentPicker.getDocumentAsync();
    if (!result.canceled) {
      await apiService.uploadDocument({
        dossier_id: medicalRecord.iddossier,
        file: result.assets[0]
      });
      loadDocuments(); // Recharger la liste
    }
  };

  return (
    <ScrollView>
      <PersonalInfo user={user} />
      <AppointmentHistory appointments={medicalRecord?.appointments} />
      <DocumentsList 
        documents={documents}
        onUpload={uploadDocument}
      />
    </ScrollView>
  );
};
```

**Endpoints utilis√©s :**
- `GET /api/dossier-medical/dossier/me`
- `GET /api/dossier-medical/:dossierId/documents`
- `POST /api/dossier-medical/documents`

---

## üë®‚Äç‚öïÔ∏è √âCRANS M√âDECIN

### 1. üìä Dashboard M√©decin

#### √âcran Principal
```typescript
// DoctorDashboardScreen.tsx
const DoctorDashboardScreen = () => {
  const [todayAppointments, setTodayAppointments] = useState([]);
  const [waitingPatients, setWaitingPatients] = useState([]);
  const [currentConsultation, setCurrentConsultation] = useState(null);

  useEffect(() => {
    loadTodayAppointments();
    loadWaitingPatients();
  }, []);

  const loadTodayAppointments = async () => {
    const appointments = await apiService.getTodayAppointments();
    setTodayAppointments(appointments);
  };

  const loadWaitingPatients = async () => {
    const waiting = await apiService.getWaitingPatients();
    setWaitingPatients(waiting);
  };

  return (
    <ScrollView>
      <StatsCards />
      <WaitingPatients 
        patients={waitingPatients}
        onMarkArrived={markPatientArrived}
        onStartConsultation={startConsultation}
      />
      <TodaySchedule appointments={todayAppointments} />
    </ScrollView>
  );
};
```

**Endpoints utilis√©s :**
- `GET /api/rendezvous/aujourd-hui`
- `GET /api/rendezvous/en-attente-consultation`

### 2. üè• Gestion des Consultations

#### √âcran de Consultation en Cours
```typescript
// ConsultationScreen.tsx
const ConsultationScreen = ({ appointment }) => {
  const [consultationNotes, setConsultationNotes] = useState('');
  const [prescription, setPrescription] = useState([]);

  const startConsultation = async () => {
    try {
      await apiService.startConsultation(appointment.idrendezvous);
      // Mettre √† jour l'√©tat local
      setConsultationStatus('EN_COURS');
    } catch (error) {
      Alert.alert('Erreur', 'Impossible de d√©marrer la consultation');
    }
  };

  const endConsultation = async () => {
    try {
      await apiService.endConsultation(appointment.idrendezvous);
      // Sauvegarder les notes et ordonnance
      await saveConsultationData();
      navigation.goBack();
    } catch (error) {
      Alert.alert('Erreur', 'Impossible de cl√¥turer la consultation');
    }
  };

  return (
    <View>
      <PatientInfo patient={appointment.patient} />
      <ConsultationNotes 
        value={consultationNotes}
        onChangeText={setConsultationNotes}
      />
      <PrescriptionForm 
        prescription={prescription}
        onChange={setPrescription}
      />
      <ActionButtons 
        onStart={startConsultation}
        onEnd={endConsultation}
      />
    </View>
  );
};
```

**Endpoints utilis√©s :**
- `PUT /api/rendezvous/:id/commencer-consultation`
- `PUT /api/rendezvous/:id/cloturer-consultation`

### 3. üìÖ Gestion de l'Agenda

#### √âcran de l'Agenda
```typescript
// AgendaScreen.tsx
const AgendaScreen = () => {
  const [agendas, setAgendas] = useState([]);
  const [timeSlots, setTimeSlots] = useState([]);

  const loadAgendas = async () => {
    const ags = await apiService.getDoctorAgendas();
    setAgendas(ags);
  };

  const createTimeSlot = async (slotData) => {
    await apiService.createTimeSlot(slotData);
    loadTimeSlots(); // Recharger
  };

  return (
    <View>
      <AgendaList 
        agendas={agendas}
        onCreateAgenda={createAgenda}
      />
      <TimeSlotsList 
        slots={timeSlots}
        onCreateSlot={createTimeSlot}
      />
    </View>
  );
};
```

**Endpoints utilis√©s :**
- `GET /api/rendezvous/medecin/:medecinId/agendas`
- `POST /api/rendezvous/agendas`
- `POST /api/rendezvous/creneaux`

---

## üîß SERVICES & UTILITAIRES

### Service API Principal
```typescript
// services/apiService.ts
class ApiService {
  private baseURL = 'http://localhost:3000/api';
  private token: string | null = null;

  async setToken(token: string) {
    this.token = token;
    await AsyncStorage.setItem('token', token);
  }

  private async getHeaders() {
    const token = await AsyncStorage.getItem('token');
    return {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    };
  }

  // Authentification
  async login(credentials: LoginRequest) {
    const response = await fetch(`${this.baseURL}/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials)
    });
    return response.json();
  }

  // Recherche de m√©decins
  async searchDoctors(params: SearchDoctorsParams) {
    const queryString = new URLSearchParams(params).toString();
    const response = await fetch(`${this.baseURL}/specialites/medecins/search?${queryString}`, {
      headers: await this.getHeaders()
    });
    return response.json();
  }

  // Rendez-vous
  async createAppointment(data: CreateAppointmentRequest) {
    const response = await fetch(`${this.baseURL}/rendezvous`, {
      method: 'POST',
      headers: await this.getHeaders(),
      body: JSON.stringify(data)
    });
    return response.json();
  }

  async getTodayAppointments() {
    const response = await fetch(`${this.baseURL}/rendezvous/aujourd-hui`, {
      headers: await this.getHeaders()
    });
    return response.json();
  }

  // Messagerie
  async createPrivateConversation(participantId: string) {
    const response = await fetch(`${this.baseURL}/messagerie/conversations/private`, {
      method: 'POST',
      headers: await this.getHeaders(),
      body: JSON.stringify({ participantId })
    });
    return response.json();
  }

  async sendMessage(data: SendMessageRequest) {
    const response = await fetch(`${this.baseURL}/messagerie/messages`, {
      method: 'POST',
      headers: await this.getHeaders(),
      body: JSON.stringify(data)
    });
    return response.json();
  }

  // Dossier m√©dical
  async getMedicalRecord() {
    const response = await fetch(`${this.baseURL}/dossier-medical/dossier/me`, {
      headers: await this.getHeaders()
    });
    return response.json();
  }

  async uploadDocument(data: UploadDocumentRequest) {
    const formData = new FormData();
    formData.append('dossier_id', data.dossier_id);
    formData.append('nom', data.nom);
    formData.append('type', data.type);
    formData.append('file', data.file);

    const response = await fetch(`${this.baseURL}/dossier-medical/documents`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${await AsyncStorage.getItem('token')}`,
        'Content-Type': 'multipart/form-data'
      },
      body: formData
    });
    return response.json();
  }
}

export const apiService = new ApiService();
```

### Service Socket.IO
```typescript
// services/socketService.ts
import { io } from 'socket.io-client';

class SocketService {
  private socket: any = null;

  connect(token: string) {
    this.socket = io('http://localhost:3000', {
      auth: { token }
    });

    this.socket.on('connect', () => {
      console.log('Connect√© au serveur');
    });
  }

  onNewMessage(callback: (message: any) => void) {
    this.socket?.on('new_message', callback);
  }

  onConsultationUpdate(callback: (data: any) => void) {
    this.socket?.on('consultation:started', callback);
    this.socket?.on('consultation:ended', callback);
  }

  disconnect() {
    this.socket?.disconnect();
  }
}

export const socketService = new SocketService();
```

---

## üì± CONFIGURATION EXPO

### app.json
```json
{
  "expo": {
    "name": "Sant√©Afrik",
    "slug": "santeafrik",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.santeafrik.app"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#FFFFFF"
      },
      "package": "com.santeafrik.app",
      "permissions": [
        "CAMERA",
        "READ_EXTERNAL_STORAGE",
        "WRITE_EXTERNAL_STORAGE"
      ]
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      [
        "expo-notifications",
        {
          "icon": "./assets/notification-icon.png",
          "color": "#ffffff"
        }
      ]
    ],
    "extra": {
      "eas": {
        "projectId": "your-project-id-here"
      }
    }
  }
}
```

---

## üöÄ D√âPLOIEMENT

### 1. Configuration EAS
```bash
# Installer EAS CLI
npm install -g @expo/eas-cli

# Initialiser le projet
eas init

# Configurer le build
eas build:configure

# Build pour Android
eas build --platform android

# Build pour iOS
eas build --platform ios
```

### 2. Variables d'environnement
```typescript
// config/environment.ts
export const config = {
  API_BASE_URL: __DEV__ 
    ? 'http://localhost:3000/api' 
    : 'https://api.santeafrik.com/api',
  SOCKET_URL: __DEV__ 
    ? 'http://localhost:3000' 
    : 'https://api.santeafrik.com'
};
```

---

## üìã CHECKLIST D'IMPL√âMENTATION

### Phase 1: Authentification ‚úÖ
- [ ] √âcran de connexion
- [ ] √âcran d'inscription avec OTP
- [ ] Gestion des tokens
- [ ] Navigation conditionnelle

### Phase 2: Recherche & R√©servation ‚úÖ
- [ ] √âcran de recherche de m√©decins
- [ ] Filtres par sp√©cialit√©
- [ ] D√©tails m√©decin
- [ ] R√©servation de RDV
- [ ] Upload de documents

### Phase 3: Dashboard & Messagerie ‚úÖ
- [ ] Dashboard patient
- [ ] Dashboard m√©decin
- [ ] Syst√®me de messagerie
- [ ] Notifications push

### Phase 4: Gestion des Consultations ‚úÖ
- [ ] Workflow pr√©sentiel complet
- [ ] Gestion de l'agenda
- [ ] Dossier m√©dical
- [ ] Ordonnances

### Phase 5: Tests & D√©ploiement ‚úÖ
- [ ] Tests unitaires
- [ ] Tests d'int√©gration
- [ ] Build de production
- [ ] D√©ploiement

---

## üéØ PROCHAINES √âTAPES

1. **Cr√©er la structure du projet** avec les dossiers recommand√©s
2. **Impl√©menter l'authentification** en premier
3. **D√©velopper les √©crans de recherche** et r√©servation
4. **Int√©grer la messagerie** avec Socket.IO
5. **Finaliser le workflow** de consultation
6. **Tester et d√©ployer**

Ce guide couvre tous les aspects n√©cessaires pour impl√©menter un frontend complet et fonctionnel ! üöÄ
